<!doctype html>
<html>
    <head>
        <title>Ladder Diagram Test</title>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
        <style> /*http://colorbrewer2.org/#type=sequential&scheme=YlGnBu&n=6*/
            #legs rect { stroke: none; }
            #legs text {
                fill: #888;
                stroke: none;
                font-family: sans-serif;
                font-weight: bold;
            }
            .technician { fill: #ffffcc; }
            .mechanic { fill: #c7e9b4; }
            .engineer { fill: #7fcdbb; }
            .supervisor { fill: #41b6c4; }
            .representative { fill: #2c7fb8; }
            .customer { fill: #253494; }
            
            #rungs path {
                stroke: none;
            }
            .request { fill: goldenrod; }
            .accept { fill: green; }
            .reject { fill: red; }
            /* #rungs path {
                fill: none;
                stroke-width: 8px;
                stroke-linecap: round;
            }
            #rungs text {
                fill: #BBB;
                stroke: none;
                font-family: sans-serif;
                font-weight: bold;
            }
            .request { stroke: goldenrod; }
            .accept { stroke: green; }
            .reject { stroke: red; } */
            /* TODO I should use two different mono hues for both source and protocols...*/
        </style>
    </head>
    <body>
        <svg width="1000" height="400"></svg>
        <script src="https://d3js.org/d3.v4.js"></script>
        <script src="../src/ladder.js"></script>
        <script type="text/javascript">

            sources = [
                { id:'Alice', class:"technician" },
                { id:'Bob', class:"mechanic" },
                { id:'Caleb', class:"engineer" },
                { id:'Donna', class:"supervisor" },
                { id:'Eric', class:"representative" },
                { id:'Fanny', class:"customer" }
            ];
            events = [
                {time:0, class: 'request', source: 'Alice', target: 'Bob', origin:'Alice'}
            ];

            let getSuperior = function ( name ) {
                let n = sources.findIndex( function(d) {return d.id==name;} );
                return (n!=-1 && n!=sources.length-1) ? sources[n+1] : null;
            };

            let getSubordinate = function( name ) {
                let n = sources.findIndex( function(d) {return d.id==name;} );
                return (n!=-1 && n!=0) ? sources[n-1] : null;
            }

            let svg = d3.selectAll('svg');
            let ladder = createLadder( svg, 'test', 0, 0, 1000, 300)
                .sources( sources )
                .events ( events );
            ladder();

            // A little generator that simulates requests in a chain of command
            d3.interval( function(elapsed) {
                let last = events[events.length-1];
                let event = null;
                
                let t = last.time + 1 + Math.random()*8;//elapsed //d3.now();

                // if a request hasn't been answered
                if (last.class=='request') {
                    
                    // half the time the superior knows the answer, Fanny always knows the answer
                    if (Math.random()<0.5 || last.target=='Fanny') {
                        // 3/4ths the time the answer is permissive
                        if(Math.random()<0.75)
                            event = { time:t, class:'accept', source:last.target, target:last.source, origin:last.origin };
                        else
                            event = { time:t, class:'reject', source:last.target, target:last.source, origin:last.origin };
                    }
                    // otherwise they pass it up the chain
                    else {
                        superior = getSuperior( last.target );
                        event = { time:t, class:'request', source:last.target, target:superior.id, origin:last.origin };
                    }

                // pass answers back down the chain of command
                } else {
                    // if the originator hasn't recieved the answer, pass it to the subordinate
                    if (last.target!=last.origin) {
                        let subordinate = getSubordinate( last.target );
                        event = { time:t, class:last.class, source:last.target, target:subordinate.id, origin:last.origin};
                    }
                    // otherwise randomly generate a new request
                    else {
                        let r = Math.floor(Math.random()*(sources.length-1));
                        let origin = sources[ r ];
                        let superior = getSuperior( origin.id );
                        event = { time:t, class:'request', source: origin.id, target:superior.id, origin:origin.id};
                    }
                }
                
                // add the message and update the diagram...
                events.push( event );
                ladder.events( events );
                ladder();
                
            }, 1000);
            
        </script>
    </body>
</html>